# -*- coding: utf-8 -*-
"""heat_opt_q_tree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYlufiLYlxfR4Z31zBqc3Uprqgaxf2N9
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from random import uniform
import torch
from torch.optim import lr_scheduler
from tqdm import tqdm
from tqdm.notebook import tqdm
import time
import json
import copy
import glob

# @title
def get_QFT(n): # return a matrix correspond to the n_qubits Quantum Fourier transform
    w=np.exp(2j*np.pi/(2**n))
    gate=np.zeros((2**n,2**n),dtype=np.complex64)
    for i in range(2**n):
        for j in range(2**n):
            gate[i][j]=w**(i*j)
    return gate/np.sqrt(2**n)


class ATA_tree_state:

    def __init__(self,dd, weights = [1], nodes = [0]):

        self.dim = dd
        self.n   = 2**dd
        self.nodes    = torch.tensor(nodes,dtype=torch.int32)
        self.weights  = torch.tensor(weights,dtype=torch.complex64)


    def get_bit_string(self,node_index):

        return torch.tensor([int(x) for x in format(node_index, 'b').zfill(self.dim)],dtype=torch.int32)


    def get_node_index(self,bit_str):

        s=''
        for x in bit_str: s += str(int(x))

        return int(s,2)


    def times_node(self,a_node,b_node):

        return self.get_node_index(torch.remainder(self.get_bit_string(a_node) + self.get_bit_string(b_node),2))


    def add_node(self,node_index, w = [0]):

        new_node = self.times_node(self.nodes[-1],node_index)

        if new_node not in self.nodes:

            self.nodes   = torch.cat((self.nodes,torch.tensor([new_node],dtype=torch.int32)))
            self.weights = torch.cat((self.weights,torch.tensor(w,dtype=torch.complex64)))

    def get_Z1(self,x):

        return (1-x)*torch.tensor([1,1],dtype=torch.int32) + x*torch.tensor([1,-1],dtype=torch.int32)

    def get_Z_all(self,bitstr):

        x = self.get_Z1(bitstr[0])

        for y in bitstr[1:]: x = torch.kron(x,self.get_Z1(y))

        return x

    def get_vector(self, w):

        z  = torch.zeros(2**self.dim,dtype=torch.complex64)

        for x,y in zip(self.nodes, self.weights):
            bits = self.get_bit_string(x)
            z  += (y)*self.get_Z_all(bits)

        return z


class ATA_state:

    def __init__(self, dd, base_nodes):

        self.dim        = dd
        self.n          = 2**dd
        self.tree       = ATA_tree_state(dd)
        self.base_nodes = base_nodes.copy()
        self.b          = torch.zeros(2**dd,dtype=torch.complex64)
        self.qft        = self.get_QFT(dd)
        self.u          = torch.exp(-2j*torch.pi*torch.tensor(range(2**dd),dtype=torch.complex64)/2**dd)
        self.state      = torch.zeros(2**dd,dtype=torch.complex64)


    def get_QFT(self, n):

        w=np.exp(2j*np.pi/(2**n))
        gate=torch.zeros((2**n,2**n),dtype=torch.complex64)
        for i in range(2**n):
            for j in range(2**n):
                gate[i][j]=w**(i*j)

        return gate/np.sqrt(2**n)


    def get_vector(self):

        z = self.tree.get_vector(self.tree.weights)

        v    = self.qft.conj().T@(z*self.b) #+ self.u*(self.qft.conj().T@(zc*self.b.flip([0]).conj()))
        v    = v/torch.sqrt(v.conj()@v)

        return v


    def get_Loss(self):

        v    = self.get_vector()
        loss = 2 - v.conj()@self.state - self.state.conj()@v

        return torch.real(loss)


    def Loss_function(self,w):

        z = self.tree.get_vector(w)
        v    = self.qft.conj().T@(z*self.b) #+ self.u*(self.qft.conj().T@(zc*self.b.flip([0]).conj()))
        v    = v/torch.sqrt(v.conj()@v)
        loss = 2 - v.conj()@self.state - self.state.conj()@v

        return torch.real(loss)


    def optimize(self, eps=1e-7, steps = 1000):

        wi   = self.tree.weights
        wi.requires_grad=True
        opt  = torch.optim.Adam([wi], lr = 0.01)

        val0, val1 = 0, self.get_Loss().detach()
        scheduler=lr_scheduler.StepLR(opt, step_size=1, gamma=0.99999)


        counter = 0
        while np.abs(val1-val0) > eps:

            opt.zero_grad()
            loss=self.Loss_function(wi)
            loss.backward()
            opt.step()
            scheduler.step()
            counter += 1

            val0, val1 = val1, self.get_Loss().detach()


        self.tree.weights = wi.detach()



    def add_Node(self, node_index, w = [0,0]):

        self.tree.add_node(node_index, w = w)



    def set_b(self,b): self.b = b



    def get_Grad(self, node_index):

        child_node = self.tree.times_node(self.tree.nodes[-1],node_index)

        new_tree = ATA_tree_state(self.dim,
                                   nodes  = np.asarray([child_node],dtype=np.int32),
                                   weights= np.asarray([0.01,0.01], dtype = np.float32))

        z = new_tree.get_vector(new_tree.weights)
        dx   = self.qft.conj().T@(z*self.b) #+ self.u*(self.qft.conj().T@(zc*self.b.flip([0]).conj()))
        x0   = self.get_vector()
        x1   = x0 +dx
        x1   = x1/torch.sqrt(x1.conj()@x1)

        loss0 = 2 - x0.conj()@self.state - self.state.conj()@x0
        loss1 = 2 - x1.conj()@self.state - self.state.conj()@x1


        grad = loss0 - loss1

        return torch.abs(grad)


    def get_next_node(self):

        grad_overlaps = []
        counter = 0

        for node in self.base_nodes:

            counter += 1
            grad_overlaps.append(self.get_Grad(node))

        return self.base_nodes[np.argmax(grad_overlaps)]


    def ATA_method(self, fidelity = 0.999, display_job = False):

        fid = self.get_fidelity()

        while fid < fidelity:

            self.optimize()
            fid = self.get_fidelity()

            if fid < fidelity:
                next_node = self.get_next_node()
                self.add_Node(next_node)

            if display_job:

                loss    = np.real(self.get_Loss())
                nodes   = self.tree.nodes

                print('Fidelity: {0:.6f}, Loss: {1:.6f}, Nodes:{2}'.format(fid,  loss, len(nodes)), end='\r')

        return None


    def get_fidelity(self):

        v = self.get_vector()
        f = (torch.abs(self.state@v))**2

        return f.item()

def get_QFT(n): # return a matrix correspond to the n_qubits Quantum Fourier transform
    w=np.exp(2j*np.pi/(2**n))
    gate=np.zeros((2**n,2**n),dtype=np.complex64)
    for i in range(2**n):
        for j in range(2**n):
            gate[i][j]=w**(i*j)
    return gate/np.sqrt(2**n)

def get_L(n): # return a n_qubits permutation matrix
    matrix=np.zeros((2**n,2**n),dtype=np.complex64)
    for i in range(2**n):
        matrix[i][i-1]=1
    return matrix


def heat_source(x,t):

    ss= 0.04
    y = np.sin(2*np.pi*20*t)*np.exp(-(x-0.25)**2/(2*ss**2))+np.sin(2*np.pi*10*t)*np.exp(-(x-0.75)**2/(2*ss**2))
    y = y*(1-np.exp(-10*t))
    return y


def get_random_heat(x, order = 2):

    yy = np.zeros(len(x))

    for nn in range(1,order+1):

        yy += uniform(-1,1)*np.sin(2*np.pi*nn*x)
        yy += uniform(-1,1)*np.cos(2*np.pi*nn*x)

    return yy

def random_heat_2(ceff,t,dd):

    xx = np.asarray(range(2**dd))/2**dd
    yy = np.zeros(2**dd)

    time_order  = len(ceff)
    space_order = len(ceff[0])

    for mm in range(time_order):
        for nn in range(space_order):

            yy += ceff[mm][nn][0]*np.sin(2*np.pi*(mm+1)*t)*np.cos(2*np.pi*(nn+1)*xx)
            yy += ceff[mm][nn][1]*np.sin(2*np.pi*(mm+1)*t)*np.sin(2*np.pi*(nn+1)*xx)
            yy += ceff[mm][nn][2]*np.cos(2*np.pi*(mm+1)*t)*np.cos(2*np.pi*(nn+1)*xx)
            yy += ceff[mm][nn][3]*np.cos(2*np.pi*(mm+1)*t)*np.sin(2*np.pi*(nn+1)*xx)

    yy = yy/np.sqrt(yy@yy)
    return yy