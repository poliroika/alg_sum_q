# -*- coding: utf-8 -*-
"""time_evolution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYlufiLYlxfR4Z31zBqc3Uprqgaxf2N9
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from random import uniform
import torch
from torch.optim import lr_scheduler
from tqdm import tqdm
from tqdm.notebook import tqdm
import time
import json
import copy
import glob
from one_time_step_opt_q import ATA_tree_tensor, ATA
from heat_opt_q_tree import ATA_tree_state, get_QFT, ATA_state, get_L, heat_source,get_random_heat, get_random_heat_2
from operations_on_trees import tree_sum, tree_multiply

def simulation(dd,dt,ff,step,time_order,space):
    cc = (1/(2**dd))**2 / dt
    qft = get_QFT(dd)
    base_nodes=[]
    for i in range(dd):
        for j in range(i,dd):
            z0=np.zeros(dd)
            z0[i]=1
            z0[j]=1
            bits=torch.tensor(z0,dtype=torch.int32)
            base_nodes.append(ATA_tree_tensor(dd).get_node_index(bits))

    ceff=[uniform(-1,1) for nn in range(4*time_order*space_order)]
    ceff=np.reshape(ceff,[time_order,space_order,4])
    b_F_0 = qft@random_heat_2(ceff,0,dd)

    data_temp = [0] * steps
    a2    = ATA_state(dd,base_nodes)

    a2.b  = torch.tensor(b_F_0 ,dtype=torch.complex64)
    for step in range(steps):
        time.sleep(0.01)
        tt = dt * (step + 1)
        a2.state = torch.tensor(random_heat_2(ceff, tt, dd), dtype=torch.complex64)
        a2.ATA_method(fidelity=0.998, display_job=False)
        data_temp[step] = copy.deepcopy(a2)

    stat_data = []
    a  = ATA(dd,cc,base_nodes)
    a.clearTree()
    b_0 = torch.tensor(b_F_0,dtype=torch.complex64)
    a.set_b(b_0)
    a.ATA_method(display_job=False, cut=True, fidelity = 0.999,len_tree = 0)
    a_sum = tree_sum(dd, dt, a.tree,data_temp[0].tree)
    my_sol = a_sum.get_vector(a_sum.weights) * b_0
    my_sol = my_sol/np.sqrt(torch.dot(my_sol.conj(),my_sol))
    b_i = copy.deepcopy(my_sol)
    true_sol = (a.get_true_sol() + dt * qft@random_heat_2(ceff,dt*(0),dd))
    my_sol = torch.tensor(my_sol,dtype =torch.complex64)
    true_sol = torch.tensor(true_sol,dtype =torch.complex64)
    true_sol = true_sol/np.sqrt(torch.dot(true_sol.conj(),true_sol))
    fid  = ((torch.abs(torch.dot(my_sol.conj(),true_sol))**2).item(), len(a_sum.nodes))
    last_step_tree = copy.deepcopy(a_sum)
    a.set_b(b_i)
    stat_data = []
    for step in range(1,steps):
      len_tree = len(np.asarray(last_step_tree.nodes).copy())
      a.ATA_method(display_job=False, cut=True, fidelity = ff, len_tree = len_tree)
      #stat_data.append({'cc':cc,'dd':dd,'fid':ff,'nodes':len(np.asarray(a.tree.nodes).copy())})

      mult_tree = tree_multiply(dd,a.tree, last_step_tree)
      mult_tree_2 = tree_sum(dd, dt, mult_tree,data_temp[step].tree)
      mult_tree_2.weights = mult_tree_2.weights/np.sqrt(torch.dot(mult_tree_2.weights.conj(),mult_tree_2.weights))
      mult_tree_3 = mult_tree_2.get_vector(mult_tree_2.weights)* b_0
      mult_tree_3 = mult_tree_3/np.sqrt(torch.dot(mult_tree_3.conj(),mult_tree_3))
      answer = a.tree.get_vector(a.tree.weights) * last_step_tree.get_vector(last_step_tree.weights)*b_0 + dt* data_temp[step].tree.get_vector(data_temp[step].tree.weights) * b_0
      answer = answer/np.sqrt(torch.dot(answer.conj(),answer))
      new_true_sol = a.get_true_sol() + dt * qft @ random_heat_2(ceff, dt * (step), dd)
      true_sol =  new_true_sol
      true_sol = torch.tensor(true_sol,dtype =torch.complex64)
      true_sol = true_sol/np.sqrt(torch.dot(true_sol.conj(),true_sol))
      last_step_tree = copy.deepcopy(mult_tree_2)
      b_i = copy.deepcopy(mult_tree_3)
      #a.clearTree()
      a.set_b(b_i)

      fid  = ((torch.abs(torch.dot(mult_tree_3.conj(),true_sol))**2).item())
      last_step_tree.cut()
      stat_data.append({'cc':cc,'dd':dd,'fid':fid,'nodes':len(np.asarray(last_step_tree.nodes).copy())})

    return stat_data