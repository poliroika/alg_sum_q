# -*- coding: utf-8 -*-
"""operations_on_trees.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYlufiLYlxfR4Z31zBqc3Uprqgaxf2N9
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from random import uniform
import torch
from torch.optim import lr_scheduler
from tqdm import tqdm
from tqdm.notebook import tqdm
import time
import json
import copy
import glob
from one_time_step_opt_q import ATA_tree_tensor

def tree_sum(dd, gamma, tree_base, tree_dop, threshold=1e-8):
    combined = {}
    for node, weight in zip(tree_base.nodes, tree_base.weights):
        combined[node] = combined.get(node, 0) + weight

    for node, weight in zip(tree_dop.nodes, tree_dop.weights):
        combined[node] = combined.get(node, 0) + gamma * weight

    filtered_combined = {
        node: weight for node, weight in combined.items() if abs(weight) >= threshold
    }

    unique_nodes = list(filtered_combined.keys())
    total_weights = list(filtered_combined.values())

    return ATA_tree_tensor(dd, total_weights, unique_nodes)

def tree_multiply(dd, tree_base, tree_dop, threshold=1e-8):
    length = len(tree_base.nodes) * len(tree_dop.nodes)
    nodes = torch.full((length,), -1, dtype=torch.int32)
    weights = torch.zeros(length, dtype=torch.complex64)

    s = 0
    for i, node_base in enumerate(tree_base.nodes):
        for j, node_dop in enumerate(tree_dop.nodes):
            combined_node = node_base ^ node_dop
            combined_weight = tree_base.weights[i] * tree_dop.weights[j]

            if abs(combined_weight) < threshold:
                continue

            existing_index = torch.where(nodes == combined_node)[0]
            if len(existing_index) > 0:
                weights[existing_index[0]] += combined_weight
            else:
                nodes[s] = combined_node
                weights[s] = combined_weight
                s += 1

    mask = (nodes != -1) & (torch.abs(weights) >= threshold)
    nodes = nodes[mask]
    weights = weights[mask]

    return ATA_tree_tensor(dd, weights.tolist(), nodes.tolist())

    return ATA_tree_tensor(dd, weights.tolist(), nodes.tolist())