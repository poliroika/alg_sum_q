# -*- coding: utf-8 -*-
"""drawing_graphs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYlufiLYlxfR4Z31zBqc3Uprqgaxf2N9
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from random import uniform
import torch
from torch.optim import lr_scheduler
from tqdm import tqdm
from tqdm.notebook import tqdm
import time
import json
import copy
import glob
from one_time_step_opt_q import ATA_tree_tensor, ATA
from heat_opt_q_tree import ATA_tree_state, get_QFT, ATA_state, get_L, heat_source,get_random_heat, get_random_heat_2
from operations_on_trees import tree_sum, tree_multiply
from time_evolution import simulation

import json
import glob
import os
import matplotlib.pyplot as plt
from tqdm import tqdm

def run_simulation_pipeline(dd, dt, ff, t, time_order, space_order, iterations=50):
    """
    Запускает серию симуляций, сохраняет результаты в файлы с именами, включающими параметры,
    затем объединяет данные из всех файлов, строит график, сохраняет его, а потом удаляет промежуточные файлы.

    Параметры:
      dd          - параметр симуляции (например, степень увеличения размерности)
      dt          - шаг по времени
      ff          - коэффициент (например, затухания или иное)
      t           - общее время моделирования
      time_order  - порядок аппроксимации по времени
      space_order - порядок аппроксимации по пространству (для включения в имена файлов)
      iterations  - количество запусков симуляции (по умолчанию 50)
    """
    dt_str = str(dt).replace('.', 'p')
    ff_str = str(ff).replace('.', 'p')
    steps = int(t / dt)
    print(f"Вычислено число шагов: {steps}")
    print("Вычисленное значение (1/(dt*(2**dd)**2)) =", 1 / (dt * (2**dd)**2))

    print("Запуск симуляций...")
    for count in tqdm(range(iterations), desc="Processing", unit="step"):
        stat_data = simulation(dd, dt, ff, steps, time_order, steps)
        filename = f"stat_data_{count+1}_dd{dd}_dt{dt_str}_ff{ff_str}_to{time_order}_so{space_order}.json"
        with open(filename, "w") as file:
            json.dump(stat_data, file)

    file_pattern = os.path.join(".", f"stat_data_*_dd{dd}_dt{dt_str}_ff{ff_str}_to{time_order}_so{space_order}.json")
    all_files = glob.glob(file_pattern)

    if not all_files:
        print("Файлы не найдены в текущей папке!")
        return

    aggregated_data = {}
    for filename in all_files:
        with open(filename, "r") as file:
            data = json.load(file)

        for step, step_data in enumerate(data, start=1):
            if step not in aggregated_data:
                aggregated_data[step] = {"fid_sum": 0, "nodes_sum": 0, "count": 0}
            aggregated_data[step]["fid_sum"] += step_data["fid"]
            aggregated_data[step]["nodes_sum"] += step_data["nodes"]
            aggregated_data[step]["count"] += 1

    averaged_data = []
    for step, values in aggregated_data.items():
        averaged_data.append({
            "step": step,
            "fid_avg": values["fid_sum"] / values["count"],
            "nodes_avg": values["nodes_sum"] / values["count"]
        })
    averaged_data = sorted(averaged_data, key=lambda x: x["step"])

    aggregated_filename = f"averaged_stat_data_dd{dd}_dt{dt_str}_ff{ff_str}_to{time_order}_so{space_order}.json"
    with open(aggregated_filename, "w") as output_file:
        json.dump(averaged_data, output_file, indent=4)
    print(f"Данные успешно объединены и сохранены в файл {aggregated_filename}.")

    steps_list = [entry["step"] for entry in averaged_data]
    nodes_avg_list = [entry["nodes_avg"] for entry in averaged_data]

    plt.figure(figsize=(10, 6))
    plt.plot(steps_list, nodes_avg_list, marker="o", linestyle="-")
    plt.title("Зависимость nodes_avg от step")
    plt.xlabel("Step")
    plt.ylabel("Nodes Average (nodes_avg)")
    plt.grid()

    plot_filename = f"nodes_avg_vs_step_dd{dd}_dt{dt_str}_ff{ff_str}_to{time_order}_so{space_order}.png"
    plt.savefig(plot_filename)
    plt.show()

    print(f"График сохранён в файл {plot_filename}.")

    for sim_file in all_files:
        try:
            os.remove(sim_file)
        except Exception as e:
            print(f"Не удалось удалить файл {sim_file}: {e}")
    print("Промежуточные файлы симуляций удалены.")